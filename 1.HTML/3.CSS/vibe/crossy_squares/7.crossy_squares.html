<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=480, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>길건너 스타일 · 최종</title>
<style>
:root{ --w:480px; --h:720px; }
*{box-sizing:border-box}
html,body{margin:0;padding:0;background:#0b0b0b;color:#1d2630}
body{width:var(--w);max-width:var(--w);margin:0 auto;overflow-y:auto;font-family:ui-sans-serif,system-ui,Apple SD Gothic Neo,Segoe UI,Roboto}

/* 공통 카드 */
.card{background:#ffffff;border:1px solid #e5e8eb;border-radius:14px;box-shadow:0 8px 24px rgba(0,0,0,.08);padding:14px;margin:12px 0}
.title{font-weight:800;font-size:18px}
.small{opacity:.75;font-size:12px}
.btn{padding:12px;border-radius:12px;border:1px solid #d0d7de;background:#fff;cursor:pointer;font-weight:700}
.btn.primary{background:#2ecc71;color:#fff;border-color:#29bf68}
.btn:active{transform:scale(.98)}
.row{display:flex;align-items:center;justify-content:space-between;gap:8px}

/* ============ 선택 화면 ============ */
#selectScreen{padding:10px}
.select-hero{
  position:relative;overflow:hidden;border-radius:14px;border:1px solid #cfe8d2;background:#bff3b7; /* 잔디 */
  height:420px;margin-top:10px
}
.select-hero::before{ /* 잔디 체크 패턴 */
  content:"";position:absolute;inset:0;background:
    linear-gradient(90deg, rgba(0,0,0,.04) 50%, transparent 50%) 0 0/48px 48px,
    linear-gradient(0deg,  rgba(0,0,0,.04) 50%, transparent 50%) 0 0/48px 48px;
  pointer-events:none
}
.hero-inner{position:absolute;inset:0;display:flex;align-items:center;justify-content:center}
.hero-name{position:absolute;bottom:26px;left:0;right:0;text-align:center}
.hero-name .ko{font-size:22px;font-weight:800}
.hero-name .en{font-size:12px;opacity:.7;margin-top:2px}
.arrow{
  position:absolute;top:50%;transform:translateY(-50%);width:44px;height:44px;border-radius:50%;
  border:1px solid #cfe8d2;background:#fff;display:flex;align-items:center;justify-content:center;font-size:20px;font-weight:800;cursor:pointer
}
.arrow:active{transform:translateY(-50%) scale(.98)}
.arrow.left{left:10px}
.arrow.right{right:10px}

/* 선택 미리보기 캔버스 */
.preview{
  display:block;width:160px !important;height:160px !important; /* 1:1 고정 */
  image-rendering: pixelated; image-rendering: crisp-edges; image-rendering:-moz-crisp-edges;
  background:#eaf6ff;border:1px solid #cfe8ff;border-radius:10px
}

/* ============ 게임 화면 ============ */
#game{display:block;width:480px !important;height:720px !important;max-width:480px !important;max-height:720px !important;
  background:#97d3ff;border-radius:12px;border:1px solid #e5e8eb;image-rendering: pixelated; image-rendering: crisp-edges; image-rendering:-moz-crisp-edges}
.stats{display:flex;gap:10px;margin-top:8px}
.stat{flex:1;text-align:center;background:#fff;border:1px solid #e5e8eb;border-radius:10px;padding:8px 10px;font-weight:700}
.actions{display:flex;gap:10px;margin-top:8px}

/* 터치 패드 */
.pad{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
.pad button{height:72px;border-radius:12px;border:1px solid #d0d7de;background:#fff;font-size:20px;font-weight:800}
.pad button:active{transform:scale(.98)}

.hidden{display:none}
</style>
</head>
<body>

<!-- ================= 선택 화면 ================= -->
<section id="selectScreen" class="card">
  <div class="title">캐릭터 선택함</div>
  <div class="small">밝은 잔디/맑은 하늘 테마 + 미니 큐브 스타일임</div>

  <div class="select-hero">
    <button class="arrow left" id="prevBtn">‹</button>
    <div class="hero-inner">
      <canvas id="preview" class="preview" width="160" height="160" aria-label="preview"></canvas>
    </div>
    <button class="arrow right" id="nextBtn">›</button>
    <div class="hero-name">
      <div class="ko" id="nameKo">호랑이</div>
      <div class="en" id="nameEn">tiger</div>
    </div>
  </div>

  <div class="row" style="margin-top:10px">
    <button class="btn primary" id="startBtn">게임 시작</button>
  </div>
</section>

<!-- ================= 게임 화면 ================= -->
<section id="gameScreen" class="hidden">
  <div class="card">
    <canvas id="game" width="480" height="720" aria-label="game"></canvas>
    <div class="stats">
      <div class="stat">점수: <span id="score">0</span></div>
      <div class="stat">레벨: <span id="level">1</span></div>
      <div class="stat">상태: <span id="status">대기중</span></div>
    </div>
    <div class="actions">
      <button class="btn" id="restartBtn">다시 시작</button>
      <button class="btn" id="backBtn">캐릭터 변경</button>
    </div>
  </div>

  <div class="card">
    <div class="title">터치 패드</div>
    <div class="pad" aria-label="touch pad">
      <div></div><button id="btnUp">▲</button><div></div>
      <button id="btnLeft">◀</button><button id="btnDown">▼</button><button id="btnRight">▶</button>
    </div>
  </div>
</section>

<script>
/* ===== 고정 스펙 ===== */
const W=480,H=720,CELL=48,COLS=W/CELL,ROWS=H/CELL;
const $=id=>document.getElementById(id);

/* ===== 캔버스 / UI ===== */
const canvas=$('game'), ctx=canvas.getContext('2d'); ctx.imageSmoothingEnabled=false;
const preview=$('preview'), pctx=preview.getContext('2d'); pctx.imageSmoothingEnabled=false;
const selectScreen=$('selectScreen'), gameScreen=$('gameScreen');
const scoreEl=$('score'), levelEl=$('level'), statusEl=$('status');

/* ===== 상태값 ===== */
let running=false, gameOver=false, last=0, elapsed=0, level=1, diff=1, score=0, shakeT=0;

/* ===== 오디오 ===== */
let actx=null;
function ensureAudio(){ if(!actx) actx=new (window.AudioContext||window.webkitAudioContext)(); }
function tone(freq,dur=0.1,vol=0.12,type='square',when=0){
  if(!actx) return; const t=actx.currentTime+when; const o=actx.createOscillator(), g=actx.createGain();
  o.type=type; o.frequency.setValueAtTime(freq,t);
  g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(vol,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+dur);
  o.connect(g).connect(actx.destination); o.start(t); o.stop(t+dur+0.04);
}
function sJump(){ tone(760,0.08,0.12,'square'); }
function sCoin(){ tone(1000,0.06,0.13,'square'); tone(1450,0.06,0.11,'square',0.06); }
function sHit(){ tone(220,0.2,0.22,'sawtooth'); }
let bgTimer=null;
function bgmStart(){ bgmStop(); ensureAudio(); const bpm=116, beat=60/bpm, notes=[262,330,392,523,392,330];
  bgTimer=setInterval(()=>{ notes.forEach((f,i)=>tone(f,beat*0.32,0.05,'triangle',i*beat*0.45)); }, beat*1000*notes.length*0.45);
}
function bgmStop(){ if(bgTimer){ clearInterval(bgTimer); bgTimer=null; } }

/* ===== 유틸 ===== */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const rand=(a,b)=>Math.random()*(b-a)+a;
const randint=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

/* ===== 배경/레벨 ===== */
const clouds=[{x:40,y:60,s:60,v:12},{x:250,y:90,s:80,v:16},{x:420,y:40,s:50,v:10}];
const lanes=[]; for(let r=0;r<ROWS;r++){ lanes[r] = (r<3||r>11)?'grass': ((r%3===0)?'water':(r%2===0?'road':'grass')); }
let waterPhase=0, roadStripe=0;

/* ===== 스프라이트(미니 큐브) ===== */
function cubeSprite(top='#ffe066', side='#f4c430', face='#cc9a06', eye='#222'){
  const a=Array(256).fill(0);
  for(let r=4;r<12;r++)for(let c=4;c<12;c++)a[r*16+c]=2; // top
  for(let r=8;r<12;r++)for(let c=4;c<12;c++)a[r*16+c]=3; // side
  a[7*16+6]=4; a[7*16+9]=4;
  return {pix:a, pal:[null, eye, top, side, eye]};
}
const SPR = {
  tiger:  cubeSprite('#ffd08a','#ffae42','#cc7a00','#281a00'),
  rabbit: cubeSprite('#fff5f5','#f5d5e6','#e7a4c5','#36222b'),
  cat:    cubeSprite('#f0e1ff','#d5b6ff','#b48cff','#2a2033'),
  dog:    cubeSprite('#e0f7ff','#bfe8ff','#8bd3ff','#1b2b33')
};
const NAMES = {
  tiger:{ko:'호랑이',en:'tiger'}, rabbit:{ko:'토끼',en:'rabbit'},
  cat:{ko:'고양이',en:'cat'},     dog:{ko:'강아지',en:'dog'}
};
function drawSprite(frame,x,y,scale=2){
  const {pix,pal}=frame;
  for(let i=0;i<256;i++){ const v=pix[i]; if(!v) continue; const cx=i%16, cy=(i/16|0);
    ctx.fillStyle=pal[v]; ctx.fillRect(x+cx*scale,y+cy*scale,scale,scale);
  }
}
function drawPreview(frame){
  pctx.clearRect(0,0,preview.width,preview.height);
  const s=4; // 더 크게
  for(let i=0;i<256;i++){ const v=frame.pix[i]; if(!v) continue; const cx=i%16, cy=(i/16|0);
    pctx.fillStyle=frame.pal[v]; pctx.fillRect(32+cx*s, 16+cy*s, s, s);
  }
}

/* ===== 캐릭터 선택(원작 스타일) ===== */
const order=['tiger','rabbit','cat','dog']; let idx=0; let chosen='tiger';
function applySelection(){
  $('nameKo').textContent=NAMES[order[idx]].ko;
  $('nameEn').textContent=NAMES[order[idx]].en;
  drawPreview(SPR[order[idx]]);
}
$('prevBtn').onclick=()=>{ idx=(idx-1+order.length)%order.length; applySelection(); };
$('nextBtn').onclick=()=>{ idx=(idx+1)%order.length; applySelection(); };
applySelection();

/* ===== 게임 오브젝트 ===== */
const player={ col:Math.floor(COLS/2), row:ROWS-1, tx:0, ty:0, x:0, y:0, sx:0, sy:0, moving:false, t:0, dur:0.12, key:'tiger' };
player.tx=player.col; player.ty=player.row; player.x=player.col*CELL; player.y=player.row*CELL; player.sx=player.x; player.sy=player.y;

let obstacles=[]; // {x,y,w,h,vx,type:'car'|'log'}
let trains=[];    // {x,y,w,h,vx,cooldown}
let coins=[];     // {col,row,active,fr,frT}
let particles=[]; // {x,y,vx,vy,t}

/* ===== 월드 구성 ===== */
function buildWorld(){
  obstacles=[]; trains=[]; coins=[]; particles=[];
  for(let r=3;r<=11;r++){
    const lane=lanes[r];
    if(lane==='road'||lane==='water'){
      const count=randint(2,3);
      for(let i=0;i<count;i++){
        const y=r*CELL, w=CELL*2, h=CELL, x=rand(0,W);
        const vx=(Math.random()<.5?-1:1)*(lane==='road'?rand(70,120):rand(50,90));
        obstacles.push({x,y,w,h,vx,type:(lane==='road'?'car':'log')});
      }
    }
  }
  [5,9].forEach(r=>trains.push({x:-600,y:r*CELL,w:CELL*4,h:CELL,vx:360,cooldown:rand(1.5,3.5)}));
  for(let i=0;i<6;i++) spawnCoin();
}
function spawnCoin(){
  for(let t=0;t<25;t++){
    const c=randint(0,COLS-1), r=randint(0,ROWS-2);
    if(lanes[r]==='water') continue;
    if(c===player.col && r===player.row) continue;
    coins.push({col:c,row:r,active:true,fr:0,frT:0}); return;
  }
}

/* ===== 입력 ===== */
function tryMove(dx,dy){
  if(gameOver||player.moving) return;
  const nc=clamp(player.col+dx,0,COLS-1), nr=clamp(player.row+dy,0,ROWS-1);
  if(nc===player.col && nr===player.row) return;
  player.col=nc; player.row=nr; player.tx=nc; player.ty=nr;
  player.sx=player.x; player.sy=player.y; player.t=0; player.moving=true;
  if(dy<0){ score+=1; scoreEl.textContent=score; sJump(); }
}
window.addEventListener('keydown',e=>{
  if(!running||gameOver) return;
  if(e.key==='ArrowUp') tryMove(0,-1);
  if(e.key==='ArrowDown') tryMove(0,1);
  if(e.key==='ArrowLeft') tryMove(-1,0);
  if(e.key==='ArrowRight') tryMove(1,0);
});
['btnUp','btnDown','btnLeft','btnRight'].forEach(id=>{
  const map={btnUp:[0,-1],btnDown:[0,1],btnLeft:[-1,0],btnRight:[1,0]};
  const [dx,dy]=map[id]; const go=()=>tryMove(dx,dy);
  $(id).addEventListener('click',go,{passive:true});
  $(id).addEventListener('touchstart',ev=>{ev.preventDefault();go();},{passive:false});
});

/* ===== 충돌박스(정밀) ===== */
function shrink(box, mx=10, my=12){ return { x:box.x+mx, y:box.y+my, w:box.w-mx*2, h:box.h-my*2 }; }
function rectHit(a,b){ return !(a.x+a.w<=b.x || b.x+b.w<=a.x || a.y+a.h<=b.y || b.y+b.h<=a.y); }

/* ===== 난이도 곡선 ===== */
function updateDifficulty(dt){
  elapsed+=dt;
  const lv=Math.floor(elapsed/12)+1;
  if(lv!==level){
    level=lv; diff=Math.min(1+level*0.18,3.2); levelEl.textContent=level;
    if(Math.random()<0.7){
      const r=randint(3,11); if(lanes[r]!=='grass'){
        const y=r*CELL, w=CELL*2, h=CELL, vx=(Math.random()<.5?-1:1)*(lanes[r]==='road'?rand(80,130):rand(60,100))*diff;
        obstacles.push({x:(vx>0?-w:W),y,w,h,vx,type:(lanes[r]==='road'?'car':'log')});
      }
    }
  }
}

/* ===== 코인/파티클 ===== */
function collectCoin(){
  for(const c of coins){
    if(c.active && c.col===player.col && c.row===player.row){
      c.active=false; score+=10; scoreEl.textContent=score; sCoin();
      for(let i=0;i<10;i++) particles.push({x:player.x+CELL/2,y:player.y+CELL/2,vx:rand(-90,90),vy:rand(-160,-80),t:0});
      if(Math.random()<0.6) spawnCoin();
    }
  }
}

/* ===== 업데이트 ===== */
function update(dt){
  updateDifficulty(dt);
  waterPhase+=dt*2.2; roadStripe+=dt*120;
  clouds.forEach(c=>{ c.x+=c.v*dt; if(c.x>W+c.s) c.x=-c.s; });
  if(shakeT>0) shakeT=Math.max(0,shakeT-dt);

  for(const o of obstacles){
    o.x += o.vx*dt*diff;
    if(o.vx>0 && o.x>W+20) o.x=-o.w;
    if(o.vx<0 && o.x<-o.w-20) o.x=W;
  }
  for(const tr of trains){
    tr.cooldown -= dt;
    if(tr.cooldown<=0){
      tr.x += tr.vx*dt*diff*1.2;
      if(tr.x>W+420){ tr.x=-rand(400,700); tr.cooldown=rand(2.0,4.0)/Math.max(1,diff-0.2); }
    }
  }
  if(player.moving){
    player.t += dt; const k=Math.min(1, player.t/player.dur); const e=1-(1-k)*(1-k);
    player.x=lerp(player.sx, player.tx*CELL, e); player.y=lerp(player.sy, player.ty*CELL, e);
    if(k>=1){ player.moving=false; player.x=player.tx*CELL; player.y=player.ty*CELL; collectCoin(); }
  }
  for(const p of particles){ p.t+=dt; p.x+=p.vx*dt; p.y+=p.vy*dt; p.vy+=320*dt; }
  particles=particles.filter(p=>p.t<0.55);

  // 충돌: 타입별 마진 다르게
  const pr = shrink({x:player.x,y:player.y,w:CELL,h:CELL}, 12, 14);
  for(const o of obstacles){
    let or;
    if(o.type==='car') or = shrink({x:o.x,y:o.y,w:o.w,h:o.h}, 12, 14);  // 좁게(관대)
    else               or = shrink({x:o.x,y:o.y,w:o.w,h:o.h}, 6, 8);    // 통나무 넉넉
    if(rectHit(pr, or)){ die(); return; }
  }
  for(const tr of trains){
    const trr = shrink({x:tr.x,y:tr.y,w:tr.w,h:tr.h}, 24, 12);
    if(rectHit(pr, trr)){ die(); return; }
  }
}

/* ===== 렌더 ===== */
function draw(){
  const sx = shakeT>0 ? (Math.random()-0.5)*10*shakeT : 0;
  const sy = shakeT>0 ? (Math.random()-0.5)*10*shakeT : 0;
  ctx.save(); ctx.translate(sx,sy);

  const g=ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#b9e3ff'); g.addColorStop(.5,'#a6dbff'); g.addColorStop(1,'#97d3ff');
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
  ctx.fillStyle='rgba(255,255,255,.35)';
  clouds.forEach(c=>{ ctx.beginPath(); ctx.arc(c.x,c.y,c.s,0,Math.PI*2); ctx.fill(); });

  for(let r=0;r<ROWS;r++){
    const y=r*CELL;
    if(lanes[r]==='grass'){
      for(let c=0;c<COLS;c++){ ctx.fillStyle=((r+c)%2===0)?'#b9f7b0':'#a8f1a0'; ctx.fillRect(c*CELL,y,CELL,CELL); }
      ctx.fillStyle='rgba(0,0,0,.05)'; for(let i=0;i<10;i++) ctx.fillRect(rand(0,W), y+rand(0,CELL-2), 2,2);
    } else if(lanes[r]==='road'){
      ctx.fillStyle='#e7ecef'; ctx.fillRect(0,y,W,CELL);
      ctx.strokeStyle='#9aa0a6'; ctx.lineWidth=3; ctx.setLineDash([10,14]); ctx.lineDashOffset=-roadStripe;
      ctx.beginPath(); ctx.moveTo(0,y+CELL/2); ctx.lineTo(W,y+CELL/2); ctx.stroke(); ctx.setLineDash([]);
    } else {
      for(let c=0;c<COLS;c++){
        const ph=Math.sin(waterPhase + c*0.6 + r*0.4)*4;
        ctx.fillStyle='#7ad0ff'; ctx.fillRect(c*CELL,y,CELL,CELL);
        ctx.fillStyle='#59c0fb'; ctx.fillRect(c*CELL,y+ph+8,CELL,8);
        ctx.fillStyle='#46aeea'; ctx.fillRect(c*CELL,y+CELL-12+ph,CELL,6);
      }
    }
  }

  // 코인
  for(const c of coins){ if(!c.active) continue; c.frT=(c.frT||0)+0.016; if(c.frT>0.1){ c.fr=(c.fr||0)+1; c.fr%=6; c.frT=0; }
    // 간단한 회전: 세 줄
    ctx.fillStyle='#ffcf3a'; ctx.fillRect(c.col*CELL+22, c.row*CELL+18, 4,12);
    ctx.fillRect(c.col*CELL+26, c.row*CELL+18, 4,12);
    ctx.fillRect(c.col*CELL+30, c.row*CELL+18, 4,12);
  }

  // 장애물
  for(const o of obstacles){
    ctx.fillStyle='rgba(0,0,0,.25)'; ctx.fillRect(o.x+8,o.y+CELL-8,o.w-16,6);
    if(o.type==='car'){
      ctx.fillStyle='#ff6b6b'; ctx.fillRect(o.x+4,o.y+10,o.w-8,CELL-20);
      ctx.fillStyle='#ffdede'; ctx.fillRect(o.x+o.w-20,o.y+14,14,12);
      ctx.fillStyle='#666'; ctx.fillRect(o.x+8,o.y+CELL-14,12,10); ctx.fillRect(o.x+o.w-22,o.y+CELL-14,12,10);
    } else { // log
      ctx.fillStyle='#cc985a'; ctx.fillRect(o.x+2,o.y+12,o.w-4,CELL-24);
      ctx.fillStyle='#b67f42'; ctx.fillRect(o.x+6,o.y+18,o.w-12,8);
      ctx.fillStyle='#e8bb7e'; ctx.fillRect(o.x+o.w-12,o.y+16,6,10);
    }
  }

  // 기차
  for(const tr of trains){
    ctx.fillStyle='rgba(0,0,0,.25)'; ctx.fillRect(tr.x, tr.y+CELL-8, tr.w, 6);
    ctx.fillStyle='#f1f3f5'; ctx.fillRect(tr.x, tr.y+6, tr.w, CELL-12);
    ctx.fillStyle='#c9ced4'; ctx.fillRect(tr.x+6, tr.y+12, tr.w-12, 16);
  }

  // 플레이어
  ctx.fillStyle='rgba(0,0,0,.23)'; ctx.fillRect(player.x+10, player.y+CELL-10, CELL-20, 7);
  // 같은 큐브 스프라이트 사용
  const pf=SPR[player.key];
  for(let i=0;i<256;i++){ const v=pf.pix[i]; if(!v) continue; const cx=i%16, cy=(i/16|0);
    ctx.fillStyle=pf.pal[v]; ctx.fillRect(Math.round(player.x)+8+cx*2, Math.round(player.y)+8+cy*2, 2,2);
  }

  // 파티클
  particles.forEach(p=>{ ctx.fillStyle='rgba(255,232,120,'+(1-p.t/0.55)+')'; ctx.fillRect(p.x,p.y,3,3); });

  if(gameOver){
    ctx.fillStyle='rgba(0,0,0,.45)'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.font='bold 26px ui-sans-serif';
    ctx.fillText('게임 오버', W/2, H/2 - 10);
    ctx.font='14px ui-sans-serif'; ctx.fillText('다시 시작을 누르면 재시작함', W/2, H/2 + 16);
  }
  ctx.restore();
}

/* ===== 루프 ===== */
function loop(ts){
  const dt=Math.min(0.033,(ts-last)/1000||0); last=ts;
  if(running&&!gameOver) update(dt);
  draw(); requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ===== 수명주기 ===== */
function die(){ running=false; gameOver=true; statusEl.textContent='게임오버'; sHit(); bgmStop(); shakeT=0.25; }
function resetGame(){
  score=0; elapsed=0; level=1; diff=1; shakeT=0;
  player.col=Math.floor(COLS/2); player.row=ROWS-1;
  player.tx=player.col; player.ty=player.row; player.x=player.col*CELL; player.y=player.row*CELL; player.sx=player.x; player.sy=player.y;
  player.moving=false; buildWorld(); gameOver=false; running=true;
  statusEl.textContent='플레이중'; scoreEl.textContent=0; levelEl.textContent=1; bgmStart();
}

/* ===== 화면 전환/버튼 ===== */
$('startBtn').onclick=()=>{ ensureAudio(); chosen=order[idx]; player.key=chosen; selectScreen.classList.add('hidden'); gameScreen.classList.remove('hidden'); window.scrollTo({top:0}); resetGame(); };
$('restartBtn').onclick=()=>{ ensureAudio(); resetGame(); window.scrollTo({top:0}); };
$('backBtn').onclick=()=>{ running=false; bgmStop(); gameOver=false; gameScreen.classList.add('hidden'); selectScreen.classList.remove('hidden'); window.scrollTo({top:0}); };

/* 탭 전환 */
document.addEventListener('visibilitychange',()=>{
  if(document.hidden){ running=false; statusEl.textContent=gameOver?'게임오버':'일시정지'; bgmStop(); }
  else if(!gameOver && !selectScreen.classList.contains('hidden')){ /* 선택화면이면 무시함 */ }
  else if(!gameOver){ running=true; statusEl.textContent='플레이중'; bgmStart(); last=performance.now(); }
});
</script>
</body>
</html>
